For this assignment I choose to make the game a 2D shooter. So the first thing I did was download  “Netcode for GameObject” from Unity package manager and what that does is that it provides network capabilities to gameObjects and scripts. After that I made an empty object called “Network Manager” and gave it the network manager script that manages the server, client and host.It also manages the network object being responsible for spawning or despawning it and keeping track of the game state for the network.

Then I also added a unity transport to the network manager and what that does is that the transport is sending the packets of information from the client to the server and vice versa. I made a player prefab and gave it the “Network object” scripted which enables the object to interact with netcode any object that needs to be networked must have the network object scripted so other prefabs like the “enemy” and “bullet” also have the network object script.

 The reason I made the player prefab was because in the network manager script you can put in your player prefab and what that does is the player prefab will spawn whenever a client connects. There is also a network prefabs list in the network manager script and there I put all the prefabs that are gonna be networked so the player, enemy, and bullet prefabs.

 I also added a “Client Network Transforms” script to the player, enemy and bullet prefabs and what that does is it lets you send the position,rotation and scale of your prefab to the server automatically. Now then the client network server is pretty much another version of the more common “network transform” the main difference is that that network transform is primarily for server owned game objects which would not work with the game objects im making sense they will be owned by the client. What client network transform does is that pretty much it is overriding “OnIsServerAuthoritative” and setting it to false pretty much makes it so the client owns the game object instead of the server.

 That results in the client moving itself and that results in a lot faster feedback for the player that they are moving and it also synchronizes the movement on the server to all the clients.  After that I made a script called “player controller” and the first thing I did was add “using Unity.Netcode” and changed the script from a monobehaviour to a network behavior. 

The Unity.netcode is what allows me to transform the script from a monobehaviour to a network behavior,while the network behavior is an abstract class that derives from monobehaviour. It is mostly used to create netcode or game logic, In order to replicate any netcode-awere properties or end and receive RPC´s a game object like the player for example must have network object complement and at least one network behavior component. 
So the next thing i did was make it so in the player controller script the player would follow the potion of the mouse. Now then the big reason I chose client network transform to add to the player was because before when I tried to move the client during playtesting both the host and client would move at the same time. That was because the client was moving locally and not sending its position to the host or server so I gave it the client network transform to be able to send its position to the server and fix the issue.

After that I decided to make a shortcut to the host and client by making a canva and giving it the network object script. Then I made 2 buttons that I put up on the top left. Afterwards i made a new script called “StartNetwork” and this script is very basic what i did was of course adding using unity.netcode and making the script a network behavior then what i did was i made 2 classes called “StartClient”  and “StartHost” and in them i just wrote networkManager.Singleton.StartClient and StartHost respectively. What that does is pretty much start the client and host so I attached the script to the canva and assigned the buttons to their respective class.    

I also created an enemy spawner script and in that script I pretty much laid down the fundamentals for spawning enemies things like minimum spawn time and maxim spawn time and what game project would get spawned in this case the enemy prefab.The important thing for this one was that in order for the enemies to start spawning the if statement “NetworkManager.Singleton.IsHost && NetworkManager.Singleton.IsClient”  must be true. Which means it checks if we are running as host and running as client so it only will check when the host has spawned in.      

For this assignment the biggest challenges I faced would be making it so the game doesn't crash when the client dies and implementing the chat system. I solve them by asking for help from my fellow students and the mentor as well as looking up information online. As for this course as a whole i will say i learned quite a bit about networking the server client relationship and the transfer of information between the server and client, thought of it was from looking up information myself rather than learning from the lectures. 
